# mysql

#### 双1配置

innodb_flush_log_at_trx_commit    
如果innodb_flush_log_at_trx_commit设置为0：log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行.该模式下，在事务提交的时候，不会主动触发写入磁盘的操作;    
如果innodb_flush_log_at_trx_commit设置为1：每次事务提交时MySQL都会把log buffer的数据写入log file(redo log)，并且flush(刷到磁盘)中去;    
如果innodb_flush_log_at_trx_commit设置为2：每次事务提交时MySQL都会把log buffer的数据写入log file，但是flush(刷到磁盘)操作并不会同时进行。该模式下,MySQL会每秒执行一次 flush(刷到磁盘)操作。   

注意：由于进程调度策略问题,这个"每秒执行一次 flush(刷到磁盘)操作"并不是保证100%的"每秒"。   

sync_binlog   
sync_binlog 的默认值是0，像操作系统刷其他文件的机制一样，MySQL不会同步到磁盘中去而是依赖操作系统来刷新binary log。   
当sync_binlog =N (N>0) ，MySQL 在每写 N次 二进制日志binary log时，会使用fdatasync()函数将它的写二进制日志binary log同步到磁盘中去。    

注意：如果启用了autocommit，那么每一个语句statement就会有一次写操作；否则每个事务对应一个写操作。    

二、性能    
两个参数在不同值时对db的纯写入的影响表现如下：    
测试场景1   
innodb_flush_log_at_trx_commit=2    
sync_binlog=1000    

测试场景2   
innodb_flush_log_at_trx_commit=1    
sync_binlog=1000    

测试场景3   
innodb_flush_log_at_trx_commit=1    
sync_binlog=1   

测试场景4   
innodb_flush_log_at_trx_commit=1    
sync_binlog=1000    

测试场景5   
innodb_flush_log_at_trx_commit=2    
sync_binlog=1000    

在以上5个场景下的TPS分别为:    
场景1            41000    
场景2           33000   
场景3           26000   
场景4           33000   

由此可见，当两个参数设置为双1的时候，写入性能最差，sync_binlog=N (N>1 ) innodb_flush_log_at_trx_commit=2 时，(在当前模式下)MySQL的写操作才能达到最高性能。    

#### B树的性质
1、定义任意非叶子结点最多只有M个儿子，且M>2；   
2、根结点的儿子数为[2, M]；     
3、除根结点以外的非叶子结点的儿子数为[M/2, M]；    
4、每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）    
5、非叶子结点的关键字个数=指向儿子的指针个数-1；     
6、非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；     
7、非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；    
8、所有叶子结点位于同一层；    

#### b+树优点
所有叶子结点的路径相同 io次数相同    
每次加载一页    
范围查询优秀    
相比b-叶子结点能存更多索引  

特点

1、B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；

2、B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

3、B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。

4、B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。

#### 聚簇索引
所谓聚簇索引，就是指主索引文件和数据文件为同一份文件，聚簇索引主要用在Innodb存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。

#### 非聚簇索引
非聚簇索引就是指B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。主要用在MyISAM存储引擎中

#### innodb和myisam区别
1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；    
2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；    
3. InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。    
4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    
5. Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；5.7以后的InnoDB支持全文索引了    
6. MyISAM表格可以被压缩后进行查询操作   
7. InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁   

#### 索引类型
Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。

1. FULLTEXT   
即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。    
全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%"这类针对文本的模糊查询效率较低的问题。    
2. HASH   
由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。    
HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。   
3. BTREE    
BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。    
4. RTREE    
RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种   

普通索引：仅加速查询    
唯一索引：加速查询 + 列值唯一（可以有null）   
主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个    
组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并   
全文索引：对文本的内容进行分词，进行搜索    

#### innodb锁类型：（for update）
record lock：记录锁，也就是仅仅锁着单独的一行    
gap lock：区间锁，仅仅锁住一个区间,锁定一个范围，但不包括记录本身(注意这里的区间都是开区间，也就是不包括边界值)。   
next-key lock：record lock+gap lock，所以next-key lock也就半开半闭区间，且是下界开，上界闭。左开右闭[8,9),如果有唯一索引，就是record lock    

InnoDB行锁是通过给聚簇索引上的索引项加锁来实现的，InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！   

行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。   

#### 共享锁【S锁】 （share mode）  
又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。    
这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。   
 
#### 排他锁【X锁】 （for update）  
又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。    
这保证了其他事务在T释放A上的锁之前不能再读取和修改A。    


#### innodb引擎的4大特性
插入缓冲（insert buffer）,二次写(double write),自适应哈希索引(ahi),预读(read ahead)

#### 索引失效的场景
1.	like 以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效。   
2.	or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效。    
3.	组合索引，不是使用第一列索引，索引失效。    
4.	数据类型出现隐式转化。如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描。    
5.	在索引列上使用 IS NULL 或 IS NOT NULL操作。索引是不索引空值的，所以这样的操作不能使用索引，可以用其他的办法处理，例如：数字类型，判断大于0，字符串类型设置一个默认值，判断是否等于默认值即可。    
6.	在索引字段上使用not，<>，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 优化方法： key<>0 改为 key>0 or key<0。   
7.	对索引字段进行计算操作。    
8.	在索引字段上使用函数。   
9.	当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。   

#### where和having都可以使用的场景
1）select addtime,name from dw_users where addtime> 1500000000   
2）select addtime,name from dw_users having addtime> 1500000000    
解释：上面的having可以用的前提是我已经筛选出了addtime字段，在这种情况下和where的效果是等效的，但是如果我没有select addtime就会报错！！因为having是从前面筛选的字段再筛选，而where是从数据表中的字段直接进行的筛选的。    
2. 只可以用where，不可以用having的情况    
1） select addtime,name from dw_users where addtime> 1500000000    
2） select phone,name from dw_users having addtime> 1500000000 //报错！！！因为前面并没有筛选出addtime字段    
3. 只可以用having，不可以用where情况   
查询每种category_id商品的价格平均值，获取平均价格大于100元的商品信息   
1）select category_id , avg(price) as ag from dw_goods group by goods_category having ag > 100   
2）select category_id , avg(price) as ag from dw_goods where ag>100 group by goods_category //报错！！因为from dw_goods 这张数据表里面没有ag这个字段    
注意:where 后面要跟的是数据表里的字段，如果我把ag换成avg(price)也是错误的！因为表里没有该字段。而having只是根据前面查询出来的是什么就可以后面接什么。   

#### mysql的复制原理大致如下
(1)首先，mysql主库在事务提交时会把数据库变更作为事件Events记录在二进制文件binlog中；mysql主库上的sys_binlog控制binlog日志刷新到磁盘。   
(2)主库推送二进制文件binlog中的事件到从库的中继日志relay log,之后从库根据中继日志重做数据库变更操作。通过逻辑复制，以此来达到数据一致。   
Mysql通过3个线程来完成主从库之间的数据复制：其中BinLog Dump线程跑在主库上，I/O线程和SQl线程跑在从库上。当从库启动复制（start slave）时，首先创建I/O线程连接主库，主库随后创建Binlog Dump线程读取数据库事件并发给I/O线程，I/O线程获取到数据库事件更新到从库的中继日志Realy log中去，之后从库上的SQl线程读取中继日志relay log 中更新的数据库事件并应用。   

Innodb的mvcc多版本并发控制用undolog控制，比如说你读取了一条数据，其他的事物再改，你读取的数据不变，甚至不是事务的修改，你读取的不会再变  

#### 幻读
在一个事务中，select一条发现没有的数据，插入然后提交事务发现插入失败，有另外的事务插入了这条数据   

#### explain
1、system：表中仅有一行（=系统表）这是const联结类型的一个特例。    
2、const：表示通过索引一次就找到，const用于比较primary key或者unique索引。因为只匹配一行数据，所以如果将主键置于where列表中，mysql能将该查询转换为一个常量    
3、eq_ref:连表查询，使用唯一索引     
4、ref:非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，可能会找多个符合条件的行，属于查找和扫描的混合体    
5、range:只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是where语句中出现了between,in等范围的查询。这种范围扫描索引扫描比全表扫描要好，因为它开始于索引的某一个点，而结束另一个点，不用全表扫描   
6、index:index 与all区别为index类型只遍历索引树。通常比all快，因为索引文件比数据文件小很多。    
7、all：遍历全表以找到匹配的行   

#### undo log
Undo Log(回滚日志)用来实现事务的原子性(回滚)和隔离性(MVCC)。
Undo Log和Redo Log正好相反，记录的是数据被修改前的信息，并且只记录逻辑变化，基于Undo Log进行的回滚只是对数据库进行一个相反的操作，而不是直接恢复物理页。

#### innodb中select * from xxx = 123 for update 锁的实现， 
xxx有没有索引：
rc是先锁所有行，然后释放掉不符合的行锁    
rr先锁所有行，不释放   
innodb的锁都是next key lock，不同情况退化成行锁或者gap lock   

xxx是主键，锁所有主键

xxx是其他索引，锁xxx，然后锁主键

原则1：加锁的基本单位是next-key lock。

原则2：查找过程中访问到的对象才会加锁。    

原则3：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。   

原则4：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。   

原则5：唯一索引上的范围查询会访问到不满足条件的第一个值为止。【注释：其实我不认为这是bug，只是唯一索引和非唯一索引保持一致】    

#### Read View
Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)

我们可以把Read View简单的理解成有三个全局属性

trx_list    
一个数值列表，用来维护Read View生成时刻系统正活跃的事务ID    
up_limit_id   
记录trx_list列表中事务ID最小的ID    
low_limit_id    
ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1   

首先比较DB_TRX_ID < up_limit_id, 如果小于，则当前事务能看到DB_TRX_ID 所在的记录，如果大于等于进入下一个判断
接下来判断 DB_TRX_ID 大于等于 low_limit_id , 如果大于等于则代表DB_TRX_ID 所在的记录在Read View生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断
判断DB_TRX_ID 是否在活跃事务之中，trx_list.contains(DB_TRX_ID)，如果在，则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在Read View生成之前就已经Commit了，你修改的结果，我当前事务是能看见的

在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；
在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View

#### mysql共享锁使用场景
用for update的业务入口A，发现B有个业务入口，只是用来查询不做updae操作，这时为了不阻塞B的频繁查询，将互斥锁改为共享锁   
降级思路的优惠券场景，适合

#### 数据库流量过大怎么处理

#### mysql 优化
尽量使用 TINYINT、SMALLINT、MEDIUM_INT 作为整数类型而非 INT，如果非负则加上 UNSIGNED。
VARCHAR 的长度只分配真正需要的空间。    
使用枚举或整数代替字符串类型。   
尽量使用 TIMESTAMP 而非 DATETIME。   
单表不要有太多字段，建议在 20 以内。    
避免使用 NULL 字段，很难查询优化且占用额外索引空间。   
用整型来存 IP。   
  
 
#### 通常一棵 B+ 树可以存放多少行数据？
这里我们先假设 B+ 树高为 2，即存在一个根节点和若干个叶子节点，那么这棵 B+ 树的存放总记录数为：根节点指针数 * 单个叶子节点记录行数。

上文我们已经说明单个叶子节点（页）中的记录数 =16K/1K=16。（这里假设一行记录的数据大小为 1k，实际上现在很多互联网业务数据记录大小通常就是 1K 左右）。

那么现在我们需要计算出非叶子节点能存放多少指针？

其实这也很好算，我们假设主键 ID 为 bigint 类型，长度为 8 字节，而指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即 16384/14=1170。

那么可以算出一棵高度为 2 的 B+ 树，能存放 1170*16=18720 条这样的数据记录。

根据同样的原理我们可以算出一个高度为 3 的 B+ 树可以存放： 1170*1170*16=21902400 条这样的记录。


#### innodb双写
刷脏页是4k 4k的刷，磁盘控制器是512b 512b的写，page写一半失败了，page会double write恢复

#### B+树为啥是双向链表
查询出的数据可以倒叙，不用再排序

#### 分库分表的联表查询
1. union all
2. 逻辑处理
