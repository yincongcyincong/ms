
### 总结
程序刚启动的时候必定有一个线程启动（主线程），将当前的栈和资源保存在g0，将该线程保存在m0。    
g0绑定m0， m0代表主线程、g0代表了线程的堆栈。调度都是在系统堆栈上跑的，也就是一定要跑在 g0 上。 

### 取p的方式
1.P本地队列中获取(runqget)一个可执行的G    
2.从全局队列取，每隔61次调度轮回从全局队列找，避免全局队列中的g被饿死   
3.P里面偷(steal)了一半，这样就足够运行了。有了“偷取”操作也就充分利用了多线程的资源。    

### p执行的调度方式
1.执行完让出cpu    
2.主动让出cpu，在实际场景中还有一些没有执行完成的G，而又需要临时停止执行，比如time.Sleep、IO阻塞等等，就需要挂起该G，把CPU让出给别人使用   
3.抢占让出CPU，sysmon()方法处于无限for循环，整个进程的生命周期监控着。retake()方法每次对所有的P遍历检查超过10ms的还在运行的G，如果有超过10ms的则通过preemptone()进行抢占   
4.系统让出cpu，进入系统调用前先保存执行现场，然后切换到_Gsyscall状态，最后标记抢占，等待被抢占走。    

### G的来源
1.gofunc创建G，先从空闲的G列表获取一个G对象，没有则创建一个新的G对象，然后runqput放到当前P待运行队列里   
2.epoll来源，首先epollwait从内核获取到一批event，也就拿到了有收到就绪的FD。netpoll的返回值是一个G链表，在该方法里只是把要被唤醒的G标记ready，然后交给外部处理   


gp.sched,而这个结构体里可以看到保存了熟悉的函数栈寄存器SP/PC/BP，能想到是把执行栈传了进去(既然是执行一个G，当然要把执行栈传进去了)。可以看到在gogo函数中实质就只是做了函数栈指针的移动。    

### G（goroutine）    
调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。 在G的眼中只有P，P就是运行G的“CPU”。 相当于两级线程 g的任务函数    

### P（processor）    
P表示逻辑processor，代表线程M的执行的上下文。 P的最大作用是其拥有的各种G对象队列、链表、cache和状态。 P的数量也代表了golang的执行并发度，即有多少goroutine可以同时运行 正确理解P   
这里的p虽然表示逻辑处理器，但P并不执行任何代码，对G来说，P相当于CPU核，G只有绑定到P才能被调度。 对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等   

### M（machine）    
M代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。 M是真正调度系统的执行者，每个M就像一个勤劳的工作者，总是从各种队列中找到可运行的G，而且这样M的可以同时存在多个。 M在绑定有效的P后，进入调度循环，而且M并不保留G状态，这是G可以跨M调度的基础。 简单理解linux的线程概念   

#### m0
m0 表示进程启动的第一个线程，也叫主线程。它和其他的m没有什么区别，要说区别的话，它是进程启动通过汇编直接复制给m0的，m0是个全局变量，而其他的m都是runtime内自己创建的。 m0 的赋值过程，可以看前面 runtime/asm_amd64.s 的代码。一个go进程只有一个m0。

#### p0
m0创建所需的p，p的数目优先取环境变量GOMAXPROCS,否则默认是cpu核数。随后把第一个p（便于理解可以叫它p0）与m0进行绑定，这样m0就有他自己的p了，就有条件执行后续的任务g了。

#### g0
首先要明确的是每个m都有一个g0，因为每个线程有一个系统堆栈，g0 虽然也是g的结构，主要是执行runtime，但和普通的g还是有差别的，最重要的差别就是栈的差别。g0 上的栈是系统分配的栈，在linux上栈大小默认固定8MB，不能扩展，也不能缩小。 而普通g一开始只有2KB大小，可扩展。在 g0 上也没有任何任务函数，也没有任何状态，并且它不能被调度程序抢占。因为调度就是在g0上跑的。

#### 上下文切换
协程切换非常简单，就是把当前协程的 CPU 寄存器状态保存起来，然后将需要切换进来的协程的 CPU 寄存器状态加载的 CPU 寄存器上就 ok 了。而且完全在用户态进行，一般来说一次协程上下文切换最多就是几十ns 这个量级。    

而线程的调度只有拥有最高权限的内核空间才可以完成，所以线程的切换涉及到用户空间和内核空间的切换，也就是特权模式切换，然后需要操作系统调度模块完成线程调度（taskstruct），而且除了和协程相同基本的 CPU 上下文，还有线程私有的栈和寄存器等。    

#### 了解过go的内存模型吗？大概讲一讲
Go内存模型指定了一系列条件，在这些条件下，可以保证在一个goroutine中读取变量可以观察到其他goroutine中对同一变量所写的值。即安全的在不同的协程中读写变量。

#### 为什么需要有这些条件呢？   
编译器或处理器不保证指令执行顺序和程序书写顺序一致，同时读写变量由于变量体积不同，也不一定是原子性的。


