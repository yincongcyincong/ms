
### 总结
程序刚启动的时候必定有一个线程启动（主线程），将当前的栈和资源保存在g0，将该线程保存在m0。    
g0绑定m0， m0代表主线程、g0代表了线程的堆栈。调度都是在系统堆栈上跑的，也就是一定要跑在 g0 上。 

### 取p的方式
1.P本地队列中获取(runqget)一个可执行的G    
2.从全局队列取，每隔61次调度轮回从全局队列找，避免全局队列中的g被饿死   
3.P里面偷(steal)了一半，这样就足够运行了。有了“偷取”操作也就充分利用了多线程的资源。    

### p执行的调度方式
1.执行完让出cpu
2.主动让出cpu，在实际场景中还有一些没有执行完成的G，而又需要临时停止执行，比如time.Sleep、IO阻塞等等，就需要挂起该G，把CPU让出给别人使用
3.抢占让出CPU，sysmon()方法处于无限for循环，整个进程的生命周期监控着。retake()方法每次对所有的P遍历检查超过10ms的还在运行的G，如果有超过10ms的则通过preemptone()进行抢占
4.系统让出cpu，进入系统调用前先保存执行现场，然后切换到_Gsyscall状态，最后标记抢占，等待被抢占走。

### G的来源
1.gofunc创建G，先从空闲的G列表获取一个G对象，没有则创建一个新的G对象，然后runqput放到当前P待运行队列里
2.epoll来源，首先epollwait从内核获取到一批event，也就拿到了有收到就绪的FD。netpoll的返回值是一个G链表，在该方法里只是把要被唤醒的G标记ready，然后交给外部处理


gp.sched,而这个结构体里可以看到保存了熟悉的函数栈寄存器SP/PC/BP，能想到是把执行栈传了进去(既然是执行一个G，当然要把执行栈传进去了)。可以看到在gogo函数中实质就只是做了函数栈指针的移动。


#### m0
m0 表示进程启动的第一个线程，也叫主线程。它和其他的m没有什么区别，要说区别的话，它是进程启动通过汇编直接复制给m0的，m0是个全局变量，而其他的m都是runtime内自己创建的。 m0 的赋值过程，可以看前面 runtime/asm_amd64.s 的代码。一个go进程只有一个m0。

#### g0
首先要明确的是每个m都有一个g0，因为每个线程有一个系统堆栈，g0 虽然也是g的结构，主要是执行runtime，但和普通的g还是有差别的，最重要的差别就是栈的差别。g0 上的栈是系统分配的栈，在linux上栈大小默认固定8MB，不能扩展，也不能缩小。 而普通g一开始只有2KB大小，可扩展。在 g0 上也没有任何任务函数，也没有任何状态，并且它不能被调度程序抢占。因为调度就是在g0上跑的。
